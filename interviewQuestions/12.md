#### 28: cookie 和 token 都存放在 header 中，為什麼不會劫持 token

1. 首先 token 不是防止 XSS 的，而是為了防止 CSRF 的
2. CSRF 攻擊的原因是瀏覽器會自動戴上 cookie, 而不會自動戴上 token

## Cookie

---

登陸後，後端生成一個 sessionId 放在 cookie 中返回給客戶端，並且服務端一直記錄著這個 sessionId，
客戶端以後每次請求都會戴上這個 sessionId，服務端通過這個 sessionId 來驗證身份之類的操作。
所以別人拿到了 cookie 拿到了 sessionId 後，就可以完全替代你

cookie 可以存一些用戶信息。因為 HTTP 是無狀態的，他不知道你有沒有登陸過。故可以通過 cookie 裡的信息解決無狀態的問題。
而瀏覽器，會自動帶上請求同域的 cookie。 (AJAX 不會自動帶 cookie)

## token

---

登陸後，後端返回一個 token 給客戶端，客戶端將這個 token 儲存起來，然後每次客戶端請求都需要開發者手動將這 token 放在 header 中帶過去。
服務端每次只需要對這個 token 進行驗證就能使用 token 中的信息進行下一步操作

後端把用戶信息和其他內容放進去，通過 jwt 生成 token，返回前端，
瀏覽器是不會自動攜帶 token 的。

## CSRF 跨站點請求偽造

---

通過瀏覽器會自動攜帶同域 cookie 的特點。
cookie 的傳遞流程是用戶在訪問站點時，服務器端生成 cookie，發送給瀏覽器儲存
當下次再訪問時瀏覽器會將該網站的 cookie 發回給服務器端

- 如果用戶登錄了 A 網站，拿到了 cookie，又點擊了惡意網站 B
- B 收到請求以後，返回一段攻擊代碼，並且發出一個請求給網站 A
- 瀏覽器會在用戶不知情的情況下，根據 B 的請求，帶著 cookie 訪問 A

由於 HTTP 是無狀態的，A 網站不知道這個請求其實是惡意網站 B 發出的，就會根據 cookie 來處理請求，從而執行了攻擊代碼。

而瀏覽器不會自動攜帶 token，所以不會劫持 token

## XSS 攻擊

---

用戶通過各種方式將惡意代碼注入到其他用戶的頁面中。就可以通過腳本獲取信息，發起請求，之類的操作。
